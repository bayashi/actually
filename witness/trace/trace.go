package trace

import (
	"fmt"
	"runtime"
	"strings"
	"unicode"
	"unicode/utf8"
)

// Info method returns a list of caller info
func Info(traceFilterFunc ...func(filepath string) bool) []string {
	var pc uintptr
	var file string
	var line int
	var funcName string
	var lastCaller string

	const stackFrameBufferSize = 10
	pcs := make([]uintptr, stackFrameBufferSize)

	callers := []string{}
	offset := 1

	for {
		n := runtime.Callers(offset, pcs)

		if n == 0 {
			break
		}

		frames := runtime.CallersFrames(pcs[:n])

		for {
			frame, more := frames.Next()
			pc = frame.PC
			file = frame.File
			line = frame.Line

			// This is a huge edge case, but it will panic if this is the case, see #180
			if file == "<autogenerated>" {
				break
			}

			f := runtime.FuncForPC(pc)
			if f == nil {
				break
			}
			funcName = f.Name()

			// testing.tRunner is the standard library function that calls
			// tests. Subtests are called directly by tRunner, without going through
			// the Test/Benchmark/Example function that contains the t.Run calls, so
			// with subtests we should break when we hit tRunner, without adding it
			// to the list of callers.
			if funcName == "testing.tRunner" {
				break
			}

			lastCaller = fmt.Sprintf("%s:%d", file, line)

			if len(strings.Split(file, "/")) > 1 && // https://github.com/stretchr/testify/pull/402
				!skipLibs(file, traceFilterFunc...) {
				callers = append(callers, lastCaller)
			}

			funcName = funcName[strings.LastIndexByte(funcName, '.')+1:]
			if isGolangTestFunc(funcName) {
				break
			}


			if !more {
				break
			}
		}

		// Next batch
		offset += cap(pcs)
	}

	if len(callers) == 0 {
		callers = append(callers, lastCaller)
	}

	return callers
}

func skipLibs(filepath string, traceFilterFunc ...func(filepath string) bool) bool {
	for _, f := range traceFilterFunc {
		if f(filepath) {
			return true
		}
	}

	return false
}

func isGolangTestFunc(funcName string) bool {
	for _, prefix := range [3]string{"Test", "Benchmark", "Example"} {
		if !strings.HasPrefix(funcName, prefix) {
			continue
		}
		if len(funcName) == len(prefix) {
			return true
		}
		r, _ := utf8.DecodeRuneInString(funcName[len(prefix):])
		if !unicode.IsLower(r) {
			return true
		}
	}

	return false
}
